# parse eve
## lexical classes
```
bind
  [#operator name: "*" precedence:3]
  [#operator name: "-" precedence:2]
  [#operator name: "/" precedence:3]
  [#operator name: "+" precedence:2]
  [#operator name: ":=" precedence:4 #commit-only]
  [#operator name: "<=" precedence:4 #commit-only]
  [#operator name: "+=" precedence:4 #commit-only]
  [#operator name: "=" precedence:4]
  [#blocking name: "@"]
  [#blocking name: "#"]
  [#blocking name: "."]
  [#blocking name: ","]
  [#blocking name: "("]
  [#blocking name: ")"]
  [#blocking name: "["]
  [#blocking name: "]"]
  [#blocking name: "{"]
  [#blocking name: "}"]
  [#blocking name: "⦑"]
  [#blocking name: "⦒"]
  [#blocking name: ":"]
  [#blocking name: "\""]
  [#digit name: "0"]
  [#digit name: "1"]
  [#digit name: "2"]
  [#digit name: "3"]
  [#digit name: "4"]
  [#digit name: "5"]
  [#digit name: "6"]
  [#digit name: "7"]
  [#digit name: "8"]
  [#digit name: "9"]
```

## single character set matcher
#### success
need to cons up the result - look at semantic returns
```
      search n = [#member set text]
             c = substring[text to:2]
             [tag:set name:c]
      bind
             n.tail := substring[text from:2]
```

#### fail
```
      search n = [#member set text]
             c = substring[text to:2]
             [tag:set name:c]
      bind
             n.fail := "character not in set {{set}}"
```


## string
### backslash

### expansion

### continue
```
```

### start
```
       search [#string text]
```
## numbers

### start
TODO - optional initial +/-
                decimal support
                exponent (and negative exponent)
semantic returns - make a string to int

```
       search [#number text]
       bind [#repeat each:[#member set:"digit"]]
```
## expressions
ok, we're going to use the phase rule

### variable
### number
### string

### start

## substring matcher
a parser combinator called #head which takes a string attribute head
and succeeds if the head is at the beginning of the string, and fails
otherwise

#### failure:
```
          search s = [#head head text]
                 not(head = substring[text to:string-length[text:head] + 1])
          bind
                 s.fail := "expected {{head}}"
```

#### success:
```
         search s = [#head head text]
                to = string-length[text:head] + 1
                head = substring[text to]
         bind
               s.tail := substring[text from:to]
```

## negation combinator

#### guard succeeded
negation feailure - the error message here is a bit opaque? pass that in?
```
        search n = [#negation-guard parent tail]
        bind parent.fail := "guard succeeded"
```

#### child failed
   negation succeeded. merge the clause attribute into the
   parent. (seems like we wont necessarily pollute the canonical
   template?)
```
        search n = [#negation-guard fail parent]
               lookup[record:parent.clause attribute value]
        bind lookup[record:parent attribute value]
```

#### set up negation
```
        search n = [#negation guard rest text]
               lookup[record:guard attribute value]
        bind
               record = [#negation-guard text parent:n]
               lookup[record attribute value]
```



## repeat combinator
#### child failed
we always succeed, but take the text from the failure and make it our tail
```
       search [#repeat-term text fail parent]
       bind parent.tail := text
```

#### child succeeded
```
       search
          r = [#repeat-term tail:text parent]
          lookup[record:parent.each attribute value]
       bind
          record = [#repeat-term text parent]
          lookup[record attribute value]
```

#### build #repeat machine
```
       search
          parent = [#repeat each text]
          lookup[record:each attribute value]
          not(parent.tail)
          not(parent.fail)
       // consider making a generic parser forker
       bind
          record = [#repeat-term text parent]
          lookup[record attribute value]
```

## sequential combinator
#### element failed
fail out the sequence, everyone has to pass for the sequence to pass
```
       search [#sequence-term text fail parent]
       bind parent.fail := fail
```

#### element succeeded
queue up the next parser
```
       search
          r = [#sequence-term tail:text parent ord: n]
          c = parent.children
          n + 1 = c.ord
          lookup[record:c attribute value]
       bind
          record = [#sequence-term text parent]
          lookup[record attribute value]
```

#### succeeded
there is a tail but no children left to process, post the
tail to the parent
```
       search
          [#sequence-term tail parent ord]
          not (parent.children.ord = ord + 1)
       bind
          parent.tail := tail
```

#### start
match on #sequence objects and kick off the process
```
       search
          parent = [#sequence text children]
          children.ord = 0
          lookup[record:children attribute value]
          not(parent.tail)
          not(parent.fail)
       bind
          record = [#sequence-term text parent]
          lookup[record attribute value]
```

## start the parse
this guy should just match on #eve-parse and text
```
   bind
      // deconstruct into a series of blocks
      [#repeat #parse
               each:[#sequence
                     children:([ord:0 #repeat each:[#negation guard:[#head head:"```"] clause:[#consume]]]
                               [ord:1 #head head:"```"]
                               [ord:2 #block]
                               [ord:3 #head head:"```"])]
               text:"fooooz ```search @zikky [#pang foo:3 bar:baz]```"]
```

## report the parse result
```
  search p = [#parse tail:""]
  commit @browser
     [#div text:"total success {{p}}"]
```
