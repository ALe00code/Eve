# Instinct

Instinct provides editor intelligence and developer tooling.

## Compiler Patterns
- `[#token line offset length surrogateOffset surrogateLength]`
- `[#document block]`
- `[#query node variable]`
  - `[#block token name? generated?]`
- `[#variable name constant? generated?]`
- `[#binding field variable]`
- `[#node]`
  - `[#record binding]`
  - `[#scan binding]`
  - `[#expression op binding?]`
  - `[#aggregate op per binding? by?]`
  - `[#action op binding?]`
  - `[#statement query input? output?]`
- `[#query node]`





## Related Node Search

Since all parse/compile information is reflected into a graph, we can perform graph walks from any sort of node to any other sort of node. We can also translate from EAVs to their originating action nodes and vice versa. There are three kinds of nodes: Expressions, Actions, and Statements. Expressions are nodes with

Here we build a static mapping of the possible routes for efficency's sake.

```
commit @instinct
  [#layer type: "eav" layer: 1]
  [#layer type: "action" layer: 2]
  [#layer type: "variable" layer: 3]
  [#layer type: "node" layer: 4]
  [#layer type: "statement" layer: 5]
```

Walk the graph from source type to destination type, filling in the intermediate steps

```
match @instinct
  search = [#search from to]
  [#layer type: from layer: from-layer]
  [#layer type: to layer: to-layer]
  intermediate-layer =
    if from-layer > to-layer then from-layer - 1
    else if from-layer < to-layer then from-layer + 1
  [#layer type: intermediate layer: intermediate-layer]
bind @instinct
  search.from += intermediate
  search.to += intermediate
```

### Statement -> EAV

To go from a statement to a node, we grab all the nodes in its bod(ies)

```
match @instinct
  search = [#search to: "node" statement]

match @compiler
  statement = [#statement query: [#query node]]

bind @instinct
  search.node := node
```

To go from a node to a variable, we grab all the variables from its binding(s)

```
match @instinct
  search = [#search to: "variable" node]

match @compiler
  node = [#node binding: [#binding variable]]

bind @instinct
  search.variable := variable
```

To go from a variable to an action, we grab all the actions with the variable in their binding(s)

```
match @instinct
  search = [#search to: "action" variable]

match @compiler
  action = [#action binding: [#binding variable]]

bind @instinct
  search.action := action
```

To go from an action to an EAV, we look up all the EAVs with that node as an origin in the scope(s) of that action

```
match @instinct
  search = [#search to: "eav" action]

match @compiler
  action = [#action scope]

match scope
  lookup[entity attribute value node: action]

bind @instinct
  search.eav := [entity attribute value]
```


### EAV -> Statement

@NOTE: These queries are very similar to their opposites, but their incoming free/bound signatures differ, and the attributes they modify do to. There may be a clever way to merge them with UDFs though.

To go from an EAV to an action, we grab the origin (node id) off the EAV
@NOTE: We don't really ever want a floppy DB, so you'll need to pass in the scopes you're interested in along with the EAVs

```
match @instinct
  search = [#search to: "action" eav: [entity attribute value] scope]

match @compiler
  action = [#action scope]

match scope
  lookup[entity attribute value node: action]

bind @instinct
  search.action := action
```

To go from an action to a variable, we grab all the variables in the action's binding(s)

```
match @instinct
  search = [#search to: "variable" action]

match @compiler
  action = [#action binding: [#binding variable]]

bind @instinct
  search.variable := variable
```

To go from a variable to a node, we grab all the nodes with the variable in their binding(s)

```
match @instinct
  search = [#search to: "node" variable]

match @compiler
  node = [#node binding: [#binding variable]]

bind @instinct
  search.node := node
```


To go from a node to a statement, we grab the parent of the query the node belongs to and ensure it's a statement

```
match @instinct
  search = [#search to: "statement" node]

match @compiler
  statement = [#statement query: [#query node]]

bind @instinct
  search.statement := statement
```

### Usage

#### Find the EAVs generated from a given variable

With current syntax:

``` eve
commit @instinct
  [#search from: "variable" to: "eav" variable: ⦑123⦒]
```

``` eve
match @instinct
  [#search variable: ⦑123⦒ eav: [entity attribute value]]

bind @browser
  [#div text: "E: {{entity}}, A: {{attribute}}, V: {{value}}"]
```

With UDFs:

``` eve
match @instinct
  [#search from: "variable" to: "eav" variable: ⦑123⦒ eav: [entity attribute value]]

bind @browser
  [#div text: "E: {{entity}}, A: {{attribute}}, V: {{value}}"]
```
